var _templateObject, _templateObject2, _templateObject3;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
import get from 'lodash/get.js';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';
import oneline from 'oneline';
import { getClientUrl, debug } from './_internal-005c7774.js';
import { getIt } from 'get-it';
import { promise } from 'get-it/middleware';
import uniqBy from 'lodash/uniqBy.js';
import startCase from 'lodash/startCase.js';
import { generateHelpUrl } from '@sanity/generate-help-url';
import { Schema } from '@sanity/schema';
import upperFirst from 'lodash/upperFirst.js';
import logSymbols from 'log-symbols';
import { getGraphQLAPIs } from './getGraphQLAPIs-4daaf106.js';
import flatten from 'lodash/flatten.js';
import pluralize from 'pluralize-esm';
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const request = getIt([promise()]);
class HttpError extends Error {
  constructor() {
    super(...arguments);
    __publicField$2(this, "statusCode");
  }
}
async function getUrlHeaders(url) {
  let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const response = await request({
    url,
    stream: true,
    maxRedirects: 0,
    method: "HEAD",
    headers
  });
  if (response.statusCode >= 400) {
    const error = new HttpError("Request returned HTTP ".concat(response.statusCode));
    error.statusCode = response.statusCode;
    throw error;
  }
  response.body.resume();
  return response.headers;
}
const SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE = "schema-lift-anonymous-object-type";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const consoleOutputter = {
  error: function () {
    return console.error(...arguments);
  }
};
class SchemaError extends Error {
  constructor(problemGroups) {
    super("Schema errors encountered");
    __publicField$1(this, "problemGroups");
    this.problemGroups = problemGroups;
  }
  print(output) {
    const logger = output || consoleOutputter;
    logger.error("Uh oh\u2026 found errors in schema:\n");
    this.problemGroups.forEach(group => {
      group.problems.forEach(problem => {
        const icon = logSymbols[problem.severity] || logSymbols.info;
        output.error("  ".concat(icon, " ").concat(upperFirst(problem.severity), ": ").concat(getPath(group.path)));
        output.error("  ".concat(problem.message));
        if (problem.helpId) {
          output.error("  See ".concat(generateHelpUrl(problem.helpId)));
        }
        output.error("");
      });
    });
  }
}
function getPath(path) {
  return path.map(segment => {
    if (segment.kind === "type" && segment.name && segment.type) {
      return "".concat(segment.name, " - (").concat(segment.type, ")");
    }
    if (segment.kind === "property" && segment.name) {
      return segment.name;
    }
    return null;
  }).filter(Boolean).join(" / ");
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const skipTypes = ["document", "reference"];
const allowedJsonTypes = ["object", "array"];
const disallowedCustomizedMembers = ["object", "array", "image", "file", "block"];
const disabledBlockFields = ["markDefs"];
const scalars = ["string", "number", "boolean"];
function getBaseType(baseSchema, typeName) {
  var _a, _b;
  if (typeName === "crossDatasetReference") {
    return Schema.compile({
      types: (((_a = baseSchema._original) == null ? void 0 : _a.types) || []).concat([{
        name: "__placeholder__",
        type: "crossDatasetReference",
        // Just needs _something_ to refer to, doesn't matter what
        to: [{
          type: "sanity.imageAsset"
        }]
      }])
    }).get("__placeholder__");
  }
  return Schema.compile({
    types: (((_b = baseSchema._original) == null ? void 0 : _b.types) || []).concat([{
      name: "__placeholder__",
      type: typeName,
      options: {
        hotspot: true
      }
    }])
  }).get("__placeholder__");
}
function getTypeName(str) {
  const name = startCase(str).replace(/\s+/g, "");
  return name === "Number" ? "Float" : name;
}
function isBaseType(type) {
  return type.name !== type.jsonType && allowedJsonTypes.includes(type.jsonType) && !skipTypes.includes(type.name) && !isReference(type);
}
function isBlockType(typeDef) {
  if (typeDef.name === "block") {
    return true;
  }
  if (typeDef.type) {
    return isBlockType(typeDef.type);
  }
  return false;
}
function hasBlockParent(typeDef) {
  if (typeDef.type && typeDef.type.name === "block" && !typeDef.type.type) {
    return true;
  }
  return Boolean(typeDef.type && hasBlockParent(typeDef.type));
}
function isArrayOfBlocks(typeDef) {
  const type = typeDef.type || typeDef;
  if (!("jsonType" in type) || type.jsonType !== "array") {
    return false;
  }
  return (type.of || []).some(hasBlockParent);
}
function isType(typeDef, typeName) {
  let type = typeDef;
  while (type) {
    if (type.name === typeName || type.type && type.type.name === typeName) {
      return true;
    }
    type = type.type;
  }
  return false;
}
function isReference(typeDef) {
  return isType(typeDef, "reference");
}
function extractFromSanitySchema(sanitySchema) {
  let extractOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _a;
  const {
    nonNullDocumentFields
  } = extractOptions;
  const unionRecursionGuards = [];
  const hasErrors = sanitySchema._validation && sanitySchema._validation.some(group => group.problems.some(problem => problem.severity === "error"));
  if (hasErrors && Array.isArray(sanitySchema._validation)) {
    throw new SchemaError(sanitySchema._validation);
  }
  const sanityTypes = ((_a = sanitySchema._original) == null ? void 0 : _a.types) || [];
  const typeNames = sanitySchema.getTypeNames();
  const unionTypes = [];
  const types = typeNames.map(name => sanitySchema.get(name)).filter(schemaType => Boolean(schemaType)).filter(isBaseType).map(type => convertType(type));
  const withUnions = [...types, ...unionTypes];
  return {
    types: withUnions,
    interfaces: [getDocumentInterfaceDefinition()]
  };
  function isTopLevelType(typeName) {
    return typeNames.includes(typeName);
  }
  function mapFieldType(field) {
    if (!field.type) {
      throw new Error("Field has no type!");
    }
    const jsonType = "jsonType" in field ? field.jsonType : "";
    const isScalar = scalars.includes(jsonType);
    if (isScalar && jsonType === "number") {
      return hasValidationFlag(field, "integer") ? "Int" : "Float";
    } else if (isScalar) {
      return getTypeName(jsonType);
    }
    const type = field.type.type || field.type;
    if (type.type) {
      return mapFieldType(type);
    }
    switch (type.name) {
      case "number":
        return hasValidationFlag(field, "integer") ? "Int" : "Float";
      default:
        return getTypeName(type.name);
    }
  }
  function isArrayType(type) {
    return Boolean("jsonType" in type && type.jsonType === "array" || type.type && type.type.jsonType === "array");
  }
  function _convertType(type, parent, options) {
    let name;
    if (type.type) {
      name = type.type.name;
    } else if ("jsonType" in type) {
      name = type.jsonType;
    }
    if (isReference(type)) {
      return getReferenceDefinition(type, parent);
    }
    if (isArrayType(type)) {
      return getArrayDefinition(type, parent, options);
    }
    if (name === "document") {
      return getDocumentDefinition(type);
    }
    if (name === "block" || name === "object") {
      return getObjectDefinition(type, parent);
    }
    if (hasFields(type)) {
      return getObjectDefinition(type, parent);
    }
    return {
      type: mapFieldType(type),
      description: getDescription(type)
    };
  }
  function convertType(type, parent) {
    let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const mapped = _convertType(type, parent || "", {
      isField: Boolean(props.fieldName)
    });
    const gqlName = props.fieldName || mapped.name;
    const originalName = type.name;
    const original = gqlName === originalName ? {} : {
      originalName
    };
    return {
      ...props,
      ...mapped,
      ...original
    };
  }
  function isField(def) {
    return !("jsonType" in def) || !def.jsonType;
  }
  function getObjectDefinition(def, parent) {
    const isInline = isField(def);
    const isDocument = def.type ? def.type.name === "document" : false;
    const actualType = isInline ? def.type : def;
    if (typeNeedsHoisting(actualType)) {
      throw createLiftTypeError(def.name, parent || "", actualType.name);
    }
    if (isInline && parent && def.type.name === "object") {
      throw createLiftTypeError(def.name, parent);
    }
    if (parent && def.type && isTopLevelType(def.type.name)) {
      return {
        type: getTypeName(def.type.name)
      };
    }
    const name = "".concat(parent || "").concat(getTypeName(def.name));
    const fields = collectFields(def);
    const firstUnprefixed = Math.max(0, fields.findIndex(field => field.name[0] !== "_"));
    const keyField = createStringField("_key");
    fields.splice(firstUnprefixed, 0, keyField);
    if (!isDocument) {
      fields.splice(firstUnprefixed + 1, 0, createStringField("_type"));
    }
    const objectIsBlock = isBlockType(def);
    const objectFields = objectIsBlock ? fields.filter(field => !disabledBlockFields.includes(field.name)) : fields;
    return {
      kind: "Type",
      name,
      type: "Object",
      description: getDescription(def),
      fields: objectFields.map(field => isArrayOfBlocks(field) ? buildRawField(field, name) : convertType(field, name, {
        fieldName: field.name
      }))
    };
  }
  function buildRawField(field, parentName) {
    return {
      ...convertType(field, parentName, {
        fieldName: "".concat(field.name, "Raw")
      }),
      type: "JSON",
      isRawAlias: true
    };
  }
  function createStringField(name) {
    return {
      name,
      type: {
        jsonType: "string",
        name: "string",
        type: {
          name: "string",
          type: void 0,
          jsonType: "string"
        }
      }
    };
  }
  function collectFields(def) {
    const fields = gatherAllFields(def);
    if (fields.length > 0) {
      return fields;
    }
    const extended = getBaseType(sanitySchema, def.name);
    return gatherAllFields(extended);
  }
  function getReferenceDefinition(def, parent) {
    const base = {
      description: getDescription(def),
      isReference: true
    };
    const candidates = arrayify(gatherAllReferenceCandidates(def));
    if (candidates.length === 0) {
      throw new Error("No candidates for reference");
    }
    return candidates.length === 1 ? {
      type: getTypeName(candidates[0].type.name),
      ...base
    } : {
      ...getUnionDefinition(candidates, def, {
        grandParent: parent
      }),
      ...base
    };
  }
  function getArrayDefinition(def, parent) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a2;
    const base = {
      description: getDescription(def),
      kind: "List"
    };
    const name = !options.isField && def.name ? {
      name: getTypeName(def.name)
    } : {};
    const candidates = ((_a2 = def.type) == null ? void 0 : _a2.type) && "of" in def.type ? arrayify(def.type.of) : def.of;
    return candidates.length === 1 ? {
      children: getArrayChildDefinition(candidates[0], def),
      ...base,
      ...name
    } : {
      children: getUnionDefinition(candidates, def, {
        grandParent: parent
      }),
      ...base,
      ...name
    };
  }
  function getArrayChildDefinition(child, arrayDef) {
    if (typeNeedsHoisting(child)) {
      throw createLiftTypeError(child.name, arrayDef.name);
    }
    if (isReference(child)) {
      return getReferenceDefinition(child, arrayDef.name);
    }
    if (scalars.includes(child.jsonType) && !scalars.includes(child.name)) {
      return {
        type: mapFieldType(child)
      };
    }
    return {
      type: getTypeName(child.name)
    };
  }
  function typeNeedsHoisting(type) {
    if (type.name === "object") {
      return true;
    }
    if (type.jsonType === "object" && !isTopLevelType(type.name)) {
      return true;
    }
    if (type.isCustomized && !isTopLevelType(type.name)) {
      return true;
    }
    if (type.isCustomized && disallowedCustomizedMembers.includes(type.name)) {
      return true;
    }
    return false;
  }
  function getUnionDefinition(candidates, parent) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (candidates.length < 2) {
      throw new Error("Not enough candidates for a union type");
    }
    const guardPathName = "".concat(typeof parent === "object" ? parent.name : parent);
    if (unionRecursionGuards.includes(guardPathName)) {
      return {};
    }
    try {
      unionRecursionGuards.push(guardPathName);
      candidates.forEach((def, i) => {
        if (typeNeedsHoisting(def)) {
          throw createLiftTypeArrayError(i, parent.name, def.type ? def.type.name : def.name, options.grandParent);
        }
      });
      const converted = candidates.map(def => convertType(def));
      const getName = def => typeof def.type === "string" ? def.type : def.type.name;
      const flattened = converted.reduce((acc, candidate) => {
        const union = unionTypes.find(item => item.name === candidate.type);
        return union ? acc.concat(union.types.map(type => ({
          type,
          isReference: candidate.isReference
        }))) : acc.concat(candidate);
      }, []);
      const allCandidatesAreDocuments = flattened.every(def => {
        const typeDef = sanityTypes.find(type => type.name === getName(def));
        return typeDef && typeDef.type === "document";
      });
      const interfaces = allCandidatesAreDocuments ? ["Document"] : void 0;
      const refs = flattened.filter(type => type.isReference).map(ref => ref.type);
      const inlineObjs = flattened.filter(type => !type.isReference).map(type => type.name || "");
      const allTypeNames = flattened.filter(type => type.name || type.type).map(type => {
        return type.isReference ? type.type : type.name;
      });
      const possibleTypes = [...new Set(allTypeNames)].sort();
      if (possibleTypes.length < 2) {
        throw new Error("Not enough types for a union type. Parent: ".concat(parent.name));
      }
      const name = possibleTypes.join("Or");
      if (!unionTypes.some(item => item.name === name)) {
        unionTypes.push({
          kind: "Union",
          name,
          types: possibleTypes,
          interfaces
        });
      }
      const references = refs.length > 0 ? refs : void 0;
      const inlineObjects = inlineObjs.length > 0 ? inlineObjs : void 0;
      return isReference(parent) ? {
        type: name,
        references
      } : {
        type: name,
        references,
        inlineObjects
      };
    } finally {
      const parentIndex = unionRecursionGuards.indexOf(guardPathName);
      if (parentIndex !== -1) {
        unionRecursionGuards.splice(parentIndex, 1);
      }
    }
  }
  function getDocumentDefinition(def) {
    const objectDef = getObjectDefinition(def);
    const fields = getDocumentInterfaceFields().concat(objectDef.fields);
    return {
      ...objectDef,
      fields,
      interfaces: ["Document"]
    };
  }
  function getDocumentInterfaceDefinition() {
    return {
      kind: "Interface",
      name: "Document",
      description: "A Sanity document",
      fields: getDocumentInterfaceFields()
    };
  }
  function getDocumentInterfaceFields() {
    const isNullable = typeof nonNullDocumentFields === "boolean" ? !nonNullDocumentFields : true;
    return [{
      fieldName: "_id",
      type: "ID",
      isNullable,
      description: "Document ID"
    }, {
      fieldName: "_type",
      type: "String",
      isNullable,
      description: "Document type"
    }, {
      fieldName: "_createdAt",
      type: "Datetime",
      isNullable,
      description: "Date the document was created"
    }, {
      fieldName: "_updatedAt",
      type: "Datetime",
      isNullable,
      description: "Date the document was last modified"
    }, {
      fieldName: "_rev",
      type: "String",
      isNullable,
      description: "Current document revision"
    }];
  }
  function arrayify(thing) {
    if (Array.isArray(thing)) {
      return thing;
    }
    return thing === null || typeof thing === "undefined" ? [] : [thing];
  }
  function hasValidationFlag(field, flag) {
    return "validation" in field && Array.isArray(field.validation) && field.validation.some(rule => rule && "_rules" in rule && rule._rules.some(item => item.flag === flag));
  }
  function getDescription(type) {
    const description = type.type && type.type.description;
    return typeof description === "string" ? description : void 0;
  }
  function gatherAllReferenceCandidates(type) {
    const allFields = gatherReferenceCandidates(type);
    return uniqBy(allFields, "name");
  }
  function gatherReferenceCandidates(type) {
    const refTo = "to" in type ? type.to : [];
    return "type" in type && type.type ? [...gatherReferenceCandidates(type.type), ...refTo] : refTo;
  }
  function gatherAllFields(type) {
    const allFields = gatherFields(type);
    return uniqBy(allFields, "name");
  }
  function gatherFields(type) {
    if ("fields" in type) {
      return type.type ? gatherFields(type.type).concat(type.fields) : type.fields;
    }
    return [];
  }
  function hasFieldsLikeShape(type) {
    return typeof type === "object" && type !== null && "fields" in type;
  }
  function hasArrayOfFields(type) {
    return hasFieldsLikeShape(type) && Array.isArray(type.fields);
  }
  function hasFields(type) {
    if (hasArrayOfFields(type)) {
      return gatherAllFields(type).length > 0;
    }
    return "type" in type && type.type ? hasFields(type.type) : false;
  }
}
function createLiftTypeArrayError(index, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
  let grandParent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
  const helpUrl = generateHelpUrl(SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  const context = [grandParent, parent].filter(Boolean).join("/");
  return new HelpfulError(oneline(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    Encountered anonymous inline ", " at index ", " for type/field ", ".\n    To use this type with GraphQL you will need to create a top-level schema type for it.\n    See ", ""])), inlineType, index, context, helpUrl), helpUrl);
}
function createLiftTypeError(typeName, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
  const helpUrl = generateHelpUrl(SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  return new HelpfulError(oneline(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n    Encountered anonymous inline ", " \"", "\" for field/type \"", "\".\n    To use this field with GraphQL you will need to create a top-level schema type for it.\n    See ", ""])), inlineType, typeName, parent, helpUrl), helpUrl);
}
class HelpfulError extends Error {
  constructor(message, helpUrl) {
    super(message);
    __publicField(this, "helpUrl");
    this.helpUrl = helpUrl;
  }
}
function isUnion(type) {
  return type.kind === "Union";
}
function isNonUnion(type) {
  return !isUnion(type) && "type" in type;
}
function isDocumentType(type) {
  return isNonUnion(type) && type.type === "Object" && Array.isArray(type.interfaces) && type.interfaces.includes("Document");
}
const filterCreators$2 = {
  ID: createIdFilters$1,
  String: createStringFilters$1,
  Url: createStringFilters$1,
  Float: createNumberFilters,
  Integer: createNumberFilters,
  Boolean: createBooleanFilters$1,
  Datetime: createDateFilters$1,
  Date: createDateFilters$1,
  Object: createObjectFilters
};
function generateTypeFilters$2(types) {
  const queryable = types.filter(isNonUnion).filter(type => type.type === "Object" && type.interfaces && type.interfaces.includes("Document"));
  return queryable.map(type => {
    const name = "".concat(type.name, "Filter");
    const fields = flatten(type.fields.map(createFieldFilters$2)).filter(Boolean);
    return {
      name,
      kind: "InputObject",
      fields: [...fields, ...getDocumentFilters$2()]
    };
  });
}
function createFieldFilters$2(field) {
  if (filterCreators$2[field.type]) {
    return filterCreators$2[field.type](field);
  }
  if (field.kind === "List") {
    return createListFilters();
  }
  if (field.isReference) {
    return createReferenceFilters(field);
  }
  return createInlineTypeFilters();
}
function getFieldName(field) {
  let modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  const suffix = modifier ? "_".concat(modifier) : "";
  return "".concat(field.fieldName).concat(suffix);
}
function getDocumentFilters$2() {
  return [{
    fieldName: "references",
    type: "ID",
    description: "All documents references the given document ID",
    constraint: {
      comparator: "REFERENCES"
    }
  }, {
    fieldName: "is_draft",
    type: "Boolean",
    description: "All documents that are drafts",
    constraint: {
      field: "_id",
      comparator: "IS_DRAFT"
    }
  }];
}
function createEqualityFilter(field) {
  return {
    fieldName: getFieldName(field),
    type: field.type,
    description: "All documents that are equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "EQUALS"
    }
  };
}
function createInequalityFilter(field) {
  return {
    fieldName: getFieldName(field, "not"),
    type: field.type,
    description: "All documents that are not equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "NOT_EQUALS"
    }
  };
}
function createDefaultFilters(field) {
  return [createEqualityFilter(field), createInequalityFilter(field)];
}
function createGtLtFilters(field) {
  return [{
    fieldName: getFieldName(field, "lt"),
    type: field.type,
    description: "All documents are less than given value",
    constraint: {
      field: field.fieldName,
      comparator: "LT"
    }
  }, {
    fieldName: getFieldName(field, "lte"),
    type: field.type,
    description: "All documents are less than or equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "LTE"
    }
  }, {
    fieldName: getFieldName(field, "gt"),
    type: field.type,
    description: "All documents are greater than given value",
    constraint: {
      field: field.fieldName,
      comparator: "GT"
    }
  }, {
    fieldName: getFieldName(field, "gte"),
    type: field.type,
    description: "All documents are greater than or equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "GTE"
    }
  }];
}
function createBooleanFilters$1(field) {
  return createDefaultFilters(field);
}
function createIdFilters$1(field) {
  return createStringFilters$1(field);
}
function createDateFilters$1(field) {
  return createDefaultFilters(field).concat(createGtLtFilters(field));
}
function createStringFilters$1(field) {
  return [...createDefaultFilters(field), {
    fieldName: getFieldName(field, "matches"),
    type: "String",
    description: "All documents contain (match) the given word/words",
    constraint: {
      field: field.fieldName,
      comparator: "MATCHES"
    }
  }, {
    fieldName: getFieldName(field, "in"),
    kind: "List",
    children: {
      type: "String",
      isNullable: false
    },
    description: "All documents match one of the given values",
    constraint: {
      field: field.fieldName,
      comparator: "IN"
    }
  }, {
    fieldName: getFieldName(field, "not_in"),
    kind: "List",
    children: {
      type: "String",
      isNullable: false
    },
    description: "None of the values match any of the given values",
    constraint: {
      field: field.fieldName,
      comparator: "NOT_IN"
    }
  }];
}
function createNumberFilters(field) {
  return createDefaultFilters(field).concat(createGtLtFilters(field));
}
function createObjectFilters(field) {
  return [];
}
function createListFilters() {
  return [];
}
function createInlineTypeFilters() {
  return [];
}
function createReferenceFilters(field) {
  return [{
    fieldName: getFieldName(field),
    type: "ID",
    constraint: {
      field: "".concat(field.fieldName, "._ref"),
      comparator: "EQUALS"
    }
  }];
}
function pluralizeTypeName(name) {
  const words = startCase(name).split(" ");
  const last = words[words.length - 1];
  const plural = pluralize(last.toLowerCase()).replace(/(\d)s$/g, "$1S");
  words[words.length - 1] = upperFirst(plural);
  return words.join("");
}
function generateTypeQueries$2(types, filters) {
  const queries = [];
  const queryable = types.filter(isNonUnion).filter(type => type.type === "Object" && type.interfaces && type.interfaces.includes("Document"));
  queryable.forEach(type => {
    queries.push({
      fieldName: type.name,
      type: type.name,
      constraints: [{
        field: "_id",
        comparator: "EQUALS",
        value: {
          kind: "argumentValue",
          argName: "i